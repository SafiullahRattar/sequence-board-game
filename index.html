<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sequence Board Game</title>
    <style>
        :root {
            --bg-color: #f5f5f5;
            --primary-color: #3498db;
            --secondary-color: #2ecc71;
            --danger-color: #e74c3c;
            --dark-color: #34495e;
            --light-color: #ecf0f1;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--dark-color);
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        h1, h2 {
            text-align: center;
        }
        
        .setup-screen, .game-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        
        .game-screen {
            display: none;
        }
        
        .form-group {
            margin-bottom: 15px;
            width: 100%;
            max-width: 400px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        input, select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #2980b9;
        }
        
        .board-container {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            gap: 20px;
            flex-wrap: wrap;
        }
        
        .board {
            display: grid;
            grid-template-columns: repeat(10, 50px);
            grid-template-rows: repeat(10, 50px);
            gap: 2px;
            background-color: #333;
            padding: 10px;
            border-radius: 10px;
        }
        
        .cell {
            background-color: white;
            border-radius: 3px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 14px;
            position: relative;
            cursor: pointer;
            user-select: none;
        }
        
        .cell.corner {
            background-color: #333;
        }
        
        .cell.corner span {
            color: white;
        }
        
        .cell img {
            width: 40px;
            height: 40px;
            object-fit: contain;
        }
        
        .token {
            position: absolute;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 2px solid white;
        }
        
        .token.blue {
            background-color: #3498db;
        }
        
        .token.green {
            background-color: #2ecc71;
        }
        
        .info-panel {
            width: 250px;
            background-color: white;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        
        .hand {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 10px;
        }
        
        .card {
            width: 40px;
            height: 60px;
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            cursor: pointer;
            font-size: 14px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .card.selected {
            border: 2px solid var(--primary-color);
            transform: translateY(-5px);
        }
        
        .card-suit {
            position: absolute;
            font-size: 10px;
        }
        
        .card-suit.top {
            top: 2px;
            left: 2px;
        }
        
        .card-suit.bottom {
            bottom: 2px;
            right: 2px;
        }
        
        .red {
            color: red;
        }
        
        .notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--dark-color);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            z-index: 100;
            display: none;
        }
        
        .player-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        
        .player-info .active {
            font-weight: bold;
            color: var(--primary-color);
        }
        
        .rules-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            overflow-y: auto;
        }
        
        .rules-content {
            background-color: white;
            margin: 10% auto;
            padding: 20px;
            width: 80%;
            max-width: 700px;
            border-radius: 10px;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        
        .close:hover {
            color: black;
        }
        
        .link-box {
            background-color: #f0f0f0;
            padding: 10px;
            border-radius: 5px;
            margin-top: 20px;
            text-align: center;
        }
        
        .link-box input {
            width: 80%;
            margin-right: 10px;
        }
        
        .sequence {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            font-weight: bold;
            color: gold;
            text-shadow: 0 0 5px black;
            z-index: 5;
        }
        
        @media (max-width: 768px) {
            .board {
                grid-template-columns: repeat(10, 35px);
                grid-template-rows: repeat(10, 35px);
            }
            
            .cell img {
                width: 30px;
                height: 30px;
            }
            
            .token {
                width: 25px;
                height: 25px;
            }
        }
    </style>
</head>
<body>
    <div class="notification" id="notification"></div>
    
    <div class="container">
        <h1>Sequence Board Game</h1>
        
        <div class="setup-screen" id="setupScreen">
            <div class="form-group">
                <label for="username">Your Username:</label>
                <input type="text" id="username" value="Player 1">
            </div>
            
            <div class="form-group">
                <label for="sequences">Sequences to Win:</label>
                <select id="sequences">
                    <option value="1">1 Sequence</option>
                    <option value="2" selected>2 Sequences</option>
                    <option value="3">3 Sequences</option>
                </select>
            </div>
            
            <div class="form-group">
                <label for="firstPlayer">First Player:</label>
                <select id="firstPlayer">
                    <option value="host" selected>You (Host)</option>
                    <option value="guest">Guest Player</option>
                </select>
            </div>
            
            <button id="createGame">Create Game</button>
            
            <div class="form-group" style="display: none;" id="joinForm">
                <label for="joinCode">Have a game code? Join here:</label>
                <input type="text" id="joinCode" placeholder="Enter game code">
                <button id="joinGame" style="margin-top: 10px;">Join Game</button>
            </div>
            
            <div class="link-box" style="display: none;" id="linkBox">
                <p>Share this link with your friend to join:</p>
                <div style="display: flex; justify-content: center;">
                    <input type="text" id="gameLink" readonly>
                    <button id="copyLink">Copy</button>
                </div>
                <p>Game Code: <span id="gameCode"></span></p>
                <p>Waiting for player to join...</p>
            </div>
        </div>
        
        <div class="game-screen" id="gameScreen">
            <div class="board-container">
                <div class="info-panel">
                    <div class="player-info">
                        <div id="player1" class="active">Player 1 (You)</div>
                        <div id="player2">Player 2</div>
                    </div>
                    
                    <div>
                        <p>Your Hand:</p>
                        <div class="hand" id="playerHand"></div>
                    </div>
                    
                    <div style="margin-top: 20px;">
                        <p>Sequences: <span id="sequenceCounter">0/2</span></p>
                        <p>Selected Card: <span id="selectedCard">None</span></p>
                    </div>
                    
                    <button id="showRules" style="margin-top: 20px;">Show Rules</button>
                </div>
                
                <div class="board" id="gameBoard"></div>
            </div>
        </div>
    </div>
    
    <div id="rulesModal" class="rules-modal">
        <div class="rules-content">
            <span class="close">&times;</span>
            <h2>Sequence Game Rules</h2>
            <h3>Objective</h3>
            <p>Form sequences of five chips in a row (vertically, horizontally, or diagonally) on the game board. The first player to form the required number of sequences wins.</p>
            
            <h3>Game Components</h3>
            <ul>
                <li>Game board with playing card images</li>
                <li>Cards (standard 52-card deck plus jokers)</li>
                <li>Colored chips for each player</li>
            </ul>
            
            <h3>Setup</h3>
            <p>Each player is dealt cards (usually 7 cards per player) and takes turns playing.</p>
            
            <h3>Special Cards</h3>
            <p><strong>One-Eyed Jacks (Jack of Hearts, Jack of Spades):</strong> These cards can be used to remove an opponent's chip from the board (except if it's part of a completed sequence).</p>
            <p><strong>Two-Eyed Jacks (Jack of Diamonds, Jack of Clubs):</strong> These are wild cards that allow a player to place their chip on any open space on the board.</p>
            
            <h3>Gameplay</h3>
            <ol>
                <li>On your turn, play a card from your hand and place your chip on a corresponding space on the board.</li>
                <li>If you play a One-Eyed Jack, remove an opponent's chip (that is not part of a completed sequence).</li>
                <li>If you play a Two-Eyed Jack, place your chip on any unoccupied space.</li>
                <li>Draw a new card to replace the one you played.</li>
                <li>The first player to complete the required number of sequences wins.</li>
            </ol>
            
            <h3>Important Notes</h3>
            <ul>
                <li>Each sequence must be five chips in a row - vertically, horizontally, or diagonally.</li>
                <li>The four corner spaces are free spaces and can be used by any player as part of a sequence.</li>
                <li>A chip may be used as part of multiple sequences.</li>
                <li>You cannot remove a chip that is part of a completed sequence.</li>
            </ul>
        </div>
    </div>
    
    <script>
        // Game Constants
        const SUITS = ['♥', '♦', '♠', '♣'];
        const VALUES = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
        const SPECIAL_JACKS = {
            'J♥': 'one-eyed', // One-eyed jack (remove)
            'J♠': 'one-eyed', // One-eyed jack (remove)
            'J♦': 'two-eyed', // Two-eyed jack (wild)
            'J♣': 'two-eyed'  // Two-eyed jack (wild)
        };
        
        // Game state
        let gameState = {
            board: [],
            deck: [],
            players: [
                { name: '', hand: [], color: 'blue', sequences: 0 },
                { name: '', hand: [], color: 'green', sequences: 0 }
            ],
            currentPlayer: 0,
            sequencesToWin: 2,
            selectedCard: null,
            sequences: [],
            gameId: null,
            isHost: true
        };
        
        // DOM Elements
        const setupScreen = document.getElementById('setupScreen');
        const gameScreen = document.getElementById('gameScreen');
        const gameBoard = document.getElementById('gameBoard');
        const playerHand = document.getElementById('playerHand');
        const player1Element = document.getElementById('player1');
        const player2Element = document.getElementById('player2');
        const sequenceCounter = document.getElementById('sequenceCounter');
        const selectedCardElement = document.getElementById('selectedCard');
        const notification = document.getElementById('notification');
        const rulesModal = document.getElementById('rulesModal');
        const closeRules = document.querySelector('.close');
        const showRulesButton = document.getElementById('showRules');
        const createGameButton = document.getElementById('createGame');
        const joinGameButton = document.getElementById('joinGame');
        const copyLinkButton = document.getElementById('copyLink');
        const joinForm = document.getElementById('joinForm');
        const linkBox = document.getElementById('linkBox');
        const gameLink = document.getElementById('gameLink');
        const gameCode = document.getElementById('gameCode');
        
        // Board layout (card positions, F = free corner, X = not used)
        const boardLayout = [
            ['F', '7♠', '8♠', '9♠', '10♠', 'Q♠', 'K♠', 'A♠', '2♦', 'F'],
            ['6♣', '5♣', '4♣', '3♣', '2♣', 'A♣', 'K♦', 'Q♦', '3♦', '2♠'],
            ['5♠', '7♣', '6♥', '5♥', '4♥', '3♥', '2♥', 'A♦', '4♦', '3♠'],
            ['4♠', '8♣', '7♥', '6♦', '5♦', '4♦', '3♦', 'K♣', '5♦', '4♠'],
            ['3♠', '9♣', '8♥', '7♦', '2♥', 'A♠', 'K♠', 'Q♣', '6♦', '5♠'],
            ['2♠', '10♣', '9♥', '8♦', 'A♥', 'K♥', 'Q♥', '10♣', '7♦', '6♠'],
            ['A♠', 'Q♣', '10♥', '9♦', 'K♥', 'Q♥', '10♥', '9♣', '8♦', '7♠'],
            ['K♠', 'J♣', 'Q♥', '10♦', 'J♦', 'J♠', 'J♥', '8♣', '9♦', '8♠'],
            ['Q♠', '10♠', 'K♥', 'J♦', 'Q♦', 'A♦', '2♣', '7♣', '10♦', '9♠'],
            ['F', 'A♥', '2♥', '3♥', '4♥', '5♥', '6♥', '7♥', '8♥', 'F']
        ];
        
        // Initialize the game
        function initGame() {
            createGameBoard();
            setupEventListeners();
            showJoinOption();
        }
        
        // Create the game board
        function createGameBoard() {
            for (let row = 0; row < 10; row++) {
                for (let col = 0; col < 10; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    
                    const cardCode = boardLayout[row][col];
                    
                    if (cardCode === 'F') {
                        cell.className = 'cell corner';
                        cell.innerHTML = '<span>FREE</span>';
                    } else if (cardCode !== 'X') {
                        const value = cardCode.slice(0, -1);
                        const suit = cardCode.slice(-1);
                        const isRed = suit === '♥' || suit === '♦';
                        
                        const cardValue = document.createElement('span');
                        cardValue.textContent = value;
                        if (isRed) cardValue.classList.add('red');
                        
                        const cardSuitTop = document.createElement('span');
                        cardSuitTop.textContent = suit;
                        cardSuitTop.className = 'card-suit top';
                        if (isRed) cardSuitTop.classList.add('red');
                        
                        const cardSuitBottom = document.createElement('span');
                        cardSuitBottom.textContent = suit;
                        cardSuitBottom.className = 'card-suit bottom';
                        if (isRed) cardSuitBottom.classList.add('red');
                        
                        cell.appendChild(cardValue);
                        cell.appendChild(cardSuitTop);
                        cell.appendChild(cardSuitBottom);
                    }
                    
                    gameBoard.appendChild(cell);
                }
            }
        }
        
        // Set up event listeners
        function setupEventListeners() {
            // Game board clicks
            gameBoard.addEventListener('click', handleBoardClick);
            
            // Show rules
            showRulesButton.addEventListener('click', () => {
                rulesModal.style.display = 'block';
            });
            
            // Close rules
            closeRules.addEventListener('click', () => {
                rulesModal.style.display = 'none';
            });
            
            // Close rules when clicking outside the modal
            window.addEventListener('click', (e) => {
                if (e.target === rulesModal) {
                    rulesModal.style.display = 'none';
                }
            });
            
            // Create game button
            createGameButton.addEventListener('click', createNewGame);
            
            // Join game button
            joinGameButton.addEventListener('click', joinExistingGame);
            
            // Copy link button
            copyLinkButton.addEventListener('click', () => {
                gameLink.select();
                document.execCommand('copy');
                showNotification('Link copied to clipboard!');
            });
        }
        
        // Show join option
        function showJoinOption() {
            // Check if URL has game code
            const urlParams = new URLSearchParams(window.location.search);
            const gameCodeParam = urlParams.get('game');
            
            if (gameCodeParam) {
                document.getElementById('joinCode').value = gameCodeParam;
                joinForm.style.display = 'block';
            } else {
                setTimeout(() => {
                    joinForm.style.display = 'block';
                }, 1000);
            }
        }
        
        // Create a new game
        function createNewGame() {
            const username = document.getElementById('username').value || 'Player 1';
            const sequencesToWin = parseInt(document.getElementById('sequences').value);
            const firstPlayer = document.getElementById('firstPlayer').value;
            
            // Generate a random game ID
            const gameId = Math.random().toString(36).substring(2, 8).toUpperCase();
            
            // Set up game state
            gameState.players[0].name = username;
            gameState.sequencesToWin = sequencesToWin;
            gameState.currentPlayer = firstPlayer === 'host' ? 0 : 1;
            gameState.gameId = gameId;
            gameState.isHost = true;
            
            // Show game link
            gameLink.value = `${window.location.href.split('?')[0]}?game=${gameId}`;
            gameCode.textContent = gameId;
            createGameButton.style.display = 'none';
            linkBox.style.display = 'block';
            
            // Start checking for player to join
            checkForPlayer();
        }
        
        // Join an existing game
        function joinExistingGame() {
            const username = document.getElementById('username').value || 'Player 2';
            const gameCodeValue = document.getElementById('joinCode').value.toUpperCase();
            
            if (!gameCodeValue) {
                showNotification('Please enter a game code');
                return;
            }
            
            // Simulate joining a game
            setTimeout(() => {
                gameState.players[0].name = 'Opponent';
                gameState.players[1].name = username;
                gameState.isHost = false;
                gameState.gameId = gameCodeValue;
                
                // Random values for the opponent's settings
                gameState.sequencesToWin = 2;
                
                startGame();
            }, 1500);
        }
        
        // Check for player to join (simulation)
        function checkForPlayer() {
            // Simulate a player joining after 5 seconds
            setTimeout(() => {
                gameState.players[1].name = 'Guest Player';
                startGame();
            }, 5000);
        }
        
        // Start the game
        function startGame() {
            setupScreen.style.display = 'none';
            gameScreen.style.display = 'block';
            
            // Update player names
            player1Element.textContent = gameState.isHost ? 
                `${gameState.players[0].name} (You)` : gameState.players[0].name;
            player2Element.textContent = gameState.isHost ? 
                gameState.players[1].name : `${gameState.players[1].name} (You)`;
            
            // Set active player
            updateActivePlayer();
            
            // Initialize the game
            initializeGameState();
            renderGame();
            
            showNotification('Game started! ' + 
                (gameState.currentPlayer === (gameState.isHost ? 0 : 1) ? 
                'Your turn!' : 'Waiting for opponent...'));
        }
        
        // Initialize game state
        function initializeGameState() {
            // Create and shuffle the deck
            gameState.deck = createDeck();
            shuffleDeck(gameState.deck);
            
            // Deal cards to players
            dealCards();
            
            // Initialize board state
            initializeBoardState();
        }
        
        // Create a standard deck of cards
        function createDeck() {
            const deck = [];
            
            // Two of each card
            for (let i = 0; i < 2; i++) {
                for (const value of VALUES) {
                    for (const suit of SUITS) {
                        deck.push(value + suit);
                    }
                }
            }
            
            return deck;
        }
        
        // Shuffle the deck
        function shuffleDeck(deck) {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
        }
        
        // Deal cards to players
        function dealCards() {
            for (let i = 0; i < 7; i++) {
                for (let player = 0; player < 2; player++) {
                    if (gameState.deck.length > 0) {
                        gameState.players[player].hand.push(gameState.deck.pop());
                    }
                }
            }
        }
        
        // Initialize board state
        function initializeBoardState() {
            gameState.board = [];
            
            for (let row = 0; row < 10; row++) {
                gameState.board[row] = [];
                for (let col = 0; col < 10; col++) {
                    const cardCode = boardLayout[row][col];
                    
                    if (cardCode === 'F') {
                        // Free corner
                        gameState.board[row][col] = { 
                            card: 'FREE', 
                            token: null, 
                            isFree: true 
                        };
                    } else if (cardCode !== 'X') {
                        gameState.board[row][col] = { 
                            card: cardCode, 
                            token: null, 
                            isFree: false 
                        };
                    } else {
                        gameState.board[row][col] = null;
                    }
                }
            }
        }
        
        // Handle board click
        function handleBoardClick(e) {
            const cell = e.target.closest('.cell');
            if (!cell) return;
            
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);
            
            // Check if it's the player's turn
            const playerIndex = gameState.isHost ? 0 : 1;
            if (gameState.currentPlayer !== playerIndex) {
                showNotification("It's not your turn!");
                return;
            }
            
            // Check if a card is selected
            if (gameState.selectedCard === null) {
                showNotification("Please select a card first!");
                return;
            }
            
            // Make the move
            makeMove(row, col);
        }
        
        // Make a move
        function makeMove(row, col) {
            const cardValue = gameState.selectedCard;
            const playerIndex = gameState.isHost ? 0 : 1;
            
            // Check if special jack
            if (SPECIAL_JACKS[cardValue]) {
                if (SPECIAL_JACKS[cardValue] === 'one-eyed') {
                    // One-eyed jack - remove opponent token
                    if (!gameState.board[row][col] || 
                        !gameState.board[row][col].token || 
                        gameState.board[row][col].token === gameState.players[playerIndex].color ||
                        isPartOfSequence(row, col)) {
                        showNotification("Invalid move for One-eyed Jack!");
                        return;
                    }
                    
                    // Remove token
                    gameState.board[row][col].token = null;
                } else {
                    // Two-eyed jack - place anywhere
                    if (!gameState.board[row][col] || 
                        gameState.board[row][col].token || 
                        gameState.board[row][col].isFree) {
                        showNotification("Invalid move for Two-eyed Jack!");
                        return;
                    }
                    
                    // Place token
                    gameState.board[row][col].token = gameState.players[playerIndex].color;
                }
            } else {
                // Regular card - must match board position
                if (!gameState.board[row][col] || 
                    gameState.board[row][col].card !== cardValue || 
                    gameState.board[row][col].token) {
                    showNotification("Invalid move!");
                    return;
                }
                
                // Place token
                gameState.board[row][col].token = gameState.players[playerIndex].color;
            }
            
            // Remove the played card from hand
            const cardIndex = gameState.players[playerIndex].hand.indexOf(cardValue);
            if (cardIndex !== -1) {
                gameState.players[playerIndex].hand.splice(cardIndex, 1);
            }
            
            // Draw a new card
            if (gameState.deck.length > 0) {
                gameState.players[playerIndex].hand.push(gameState.deck.pop());
            }
            
            // Clear selected card
            gameState.selectedCard = null;
            
            // Check for sequences
            checkForSequences();
            
            // Check for win
            if (checkForWin()) {
                showNotification(`${gameState.players[playerIndex].name} wins!`);
                setTimeout(() => {
                    alert(`${gameState.players[playerIndex].name} wins the game!`);
                    window.location.reload();
                }, 1000);
                return;
            }
            
            // Switch players
            gameState.currentPlayer = 1 - gameState.currentPlayer;
            
            // Re-render
            renderGame();
            
            // If it's AI's turn
            simulateOpponentTurn();
        }
        
        // Check if a position is part of a sequence
        function isPartOfSequence(row, col) {
            for (const seq of gameState.sequences) {
                for (const pos of seq.positions) {
                    if (pos.row === row && pos.col === col) {
                        return true;
                    }
                }
            }
            return false;
        }
        
// Continue from where the code left off...

// Check for sequences
function checkForSequences() {
    const newSequences = [];
    const playerIndex = gameState.currentPlayer;
    const playerColor = gameState.players[playerIndex].color;
    
    // Check horizontal sequences
    for (let row = 0; row < 10; row++) {
        for (let col = 0; col < 6; col++) {
            const positions = [];
            let valid = true;
            
            for (let i = 0; i < 5; i++) {
                const cell = gameState.board[row][col + i];
                if (!cell || cell.token !== playerColor && !cell.isFree) {
                    valid = false;
                    break;
                }
                
                positions.push({ row, col: col + i });
            }
            
            if (valid) {
                // Check if this sequence overlaps with existing ones
                let isNew = true;
                for (const seq of gameState.sequences) {
                    if (seq.color === playerColor && seq.direction === 'horizontal') {
                        let overlapCount = 0;
                        for (const pos of positions) {
                            for (const existingPos of seq.positions) {
                                if (pos.row === existingPos.row && pos.col === existingPos.col) {
                                    overlapCount++;
                                }
                            }
                        }
                        
                        // If there's significant overlap, it's not a new sequence
                        if (overlapCount >= 4) {
                            isNew = false;
                            break;
                        }
                    }
                }
                
                if (isNew) {
                    newSequences.push({
                        color: playerColor,
                        direction: 'horizontal',
                        positions: positions
                    });
                }
            }
        }
    }
    
    // Check vertical sequences
    for (let row = 0; row < 6; row++) {
        for (let col = 0; col < 10; col++) {
            const positions = [];
            let valid = true;
            
            for (let i = 0; i < 5; i++) {
                const cell = gameState.board[row + i][col];
                if (!cell || cell.token !== playerColor && !cell.isFree) {
                    valid = false;
                    break;
                }
                
                positions.push({ row: row + i, col });
            }
            
            if (valid) {
                // Check if this sequence overlaps with existing ones
                let isNew = true;
                for (const seq of gameState.sequences) {
                    if (seq.color === playerColor && seq.direction === 'vertical') {
                        let overlapCount = 0;
                        for (const pos of positions) {
                            for (const existingPos of seq.positions) {
                                if (pos.row === existingPos.row && pos.col === existingPos.col) {
                                    overlapCount++;
                                }
                            }
                        }
                        
                        // If there's significant overlap, it's not a new sequence
                        if (overlapCount >= 4) {
                            isNew = false;
                            break;
                        }
                    }
                }
                
                if (isNew) {
                    newSequences.push({
                        color: playerColor,
                        direction: 'vertical',
                        positions: positions
                    });
                }
            }
        }
    }
    
    // Check diagonal sequences (top-left to bottom-right)
    for (let row = 0; row < 6; row++) {
        for (let col = 0; col < 6; col++) {
            const positions = [];
            let valid = true;
            
            for (let i = 0; i < 5; i++) {
                const cell = gameState.board[row + i][col + i];
                if (!cell || cell.token !== playerColor && !cell.isFree) {
                    valid = false;
                    break;
                }
                
                positions.push({ row: row + i, col: col + i });
            }
            
            if (valid) {
                // Check if this sequence overlaps with existing ones
                let isNew = true;
                for (const seq of gameState.sequences) {
                    if (seq.color === playerColor && seq.direction === 'diagonal-right') {
                        let overlapCount = 0;
                        for (const pos of positions) {
                            for (const existingPos of seq.positions) {
                                if (pos.row === existingPos.row && pos.col === existingPos.col) {
                                    overlapCount++;
                                }
                            }
                        }
                        
                        // If there's significant overlap, it's not a new sequence
                        if (overlapCount >= 4) {
                            isNew = false;
                            break;
                        }
                    }
                }
                
                if (isNew) {
                    newSequences.push({
                        color: playerColor,
                        direction: 'diagonal-right',
                        positions: positions
                    });
                }
            }
        }
    }
    
    // Check diagonal sequences (top-right to bottom-left)
    for (let row = 0; row < 6; row++) {
        for (let col = 4; col < 10; col++) {
            const positions = [];
            let valid = true;
            
            for (let i = 0; i < 5; i++) {
                const cell = gameState.board[row + i][col - i];
                if (!cell || cell.token !== playerColor && !cell.isFree) {
                    valid = false;
                    break;
                }
                
                positions.push({ row: row + i, col: col - i });
            }
            
            if (valid) {
                // Check if this sequence overlaps with existing ones
                let isNew = true;
                for (const seq of gameState.sequences) {
                    if (seq.color === playerColor && seq.direction === 'diagonal-left') {
                        let overlapCount = 0;
                        for (const pos of positions) {
                            for (const existingPos of seq.positions) {
                                if (pos.row === existingPos.row && pos.col === existingPos.col) {
                                    overlapCount++;
                                }
                            }
                        }
                        
                        // If there's significant overlap, it's not a new sequence
                        if (overlapCount >= 4) {
                            isNew = false;
                            break;
                        }
                    }
                }
                
                if (isNew) {
                    newSequences.push({
                        color: playerColor,
                        direction: 'diagonal-left',
                        positions: positions
                    });
                }
            }
        }
    }
    
    // Add new sequences to the game state
    if (newSequences.length > 0) {
        for (const seq of newSequences) {
            gameState.sequences.push(seq);
            gameState.players[playerIndex].sequences++;
            
            // Mark sequence on the board
            for (const pos of seq.positions) {
                const cellElement = document.querySelector(`.cell[data-row="${pos.row}"][data-col="${pos.col}"]`);
                if (cellElement && !cellElement.querySelector('.sequence')) {
                    const sequenceMarker = document.createElement('div');
                    sequenceMarker.className = 'sequence';
                    sequenceMarker.innerHTML = '★';
                    cellElement.appendChild(sequenceMarker);
                }
            }
        }
        
        // Update sequence counter
        updateSequenceCounter();
    }
}

// Check for win
function checkForWin() {
    const playerIndex = gameState.currentPlayer;
    return gameState.players[playerIndex].sequences >= gameState.sequencesToWin;
}

// Update sequence counter
function updateSequenceCounter() {
    const playerIndex = gameState.isHost ? 0 : 1;
    sequenceCounter.textContent = `${gameState.players[playerIndex].sequences}/${gameState.sequencesToWin}`;
}

// Update active player indicator
function updateActivePlayer() {
    const isPlayerTurn = gameState.currentPlayer === (gameState.isHost ? 0 : 1);
    player1Element.classList.toggle('active', gameState.isHost ? isPlayerTurn : !isPlayerTurn);
    player2Element.classList.toggle('active', gameState.isHost ? !isPlayerTurn : isPlayerTurn);
}

// Render the game state
function renderGame() {
    renderBoard();
    renderHand();
    updateSelectedCard();
    updateActivePlayer();
}

// Render the board
function renderBoard() {
    // Clear existing tokens
    const tokens = document.querySelectorAll('.token');
    tokens.forEach(token => token.remove());
    
    // Render current board state
    for (let row = 0; row < 10; row++) {
        for (let col = 0; col < 10; col++) {
            const cell = gameState.board[row][col];
            if (cell && cell.token) {
                const cellElement = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
                
                if (cellElement) {
                    const token = document.createElement('div');
                    token.className = `token ${cell.token}`;
                    cellElement.appendChild(token);
                }
            }
        }
    }
}

// Render player's hand
function renderHand() {
    playerHand.innerHTML = '';
    
    const playerIndex = gameState.isHost ? 0 : 1;
    const hand = gameState.players[playerIndex].hand;
    
    hand.forEach(card => {
        const cardElement = document.createElement('div');
        cardElement.className = 'card';
        if (card === gameState.selectedCard) {
            cardElement.classList.add('selected');
        }
        
        const value = card.slice(0, -1);
        const suit = card.slice(-1);
        const isRed = suit === '♥' || suit === '♦';
        
        const cardValue = document.createElement('span');
        cardValue.textContent = value;
        if (isRed) cardValue.classList.add('red');
        
        const cardSuitTop = document.createElement('span');
        cardSuitTop.textContent = suit;
        cardSuitTop.className = 'card-suit top';
        if (isRed) cardSuitTop.classList.add('red');
        
        const cardSuitBottom = document.createElement('span');
        cardSuitBottom.textContent = suit;
        cardSuitBottom.className = 'card-suit bottom';
        if (isRed) cardSuitBottom.classList.add('red');
        
        cardElement.appendChild(cardValue);
        cardElement.appendChild(cardSuitTop);
        cardElement.appendChild(cardSuitBottom);
        
        cardElement.addEventListener('click', () => {
            // Select or deselect card
            if (gameState.selectedCard === card) {
                gameState.selectedCard = null;
            } else {
                gameState.selectedCard = card;
            }
            updateSelectedCard();
            renderHand();
        });
        
        playerHand.appendChild(cardElement);
    });
}

// Update selected card display
function updateSelectedCard() {
    selectedCardElement.textContent = gameState.selectedCard || 'None';
}

// Show notification
function showNotification(message) {
    notification.textContent = message;
    notification.style.display = 'block';
    
    // Hide after 3 seconds
    setTimeout(() => {
        notification.style.display = 'none';
    }, 3000);
}

// Simulate opponent turn (for testing/demo)
function simulateOpponentTurn() {
    const opponentIndex = gameState.isHost ? 1 : 0;
    
    // If it's the opponent's turn
    if (gameState.currentPlayer === opponentIndex) {
        // Add a small delay to simulate thinking
        setTimeout(() => {
            // Find a valid move
            makeRandomOpponentMove();
        }, 1500);
    }
}

// Make a random opponent move (for testing/demo)
function makeRandomOpponentMove() {
    const opponentIndex = gameState.isHost ? 1 : 0;
    const hand = gameState.players[opponentIndex].hand;
    
    if (hand.length === 0) return;
    
    // Try to make a valid move
    let moveMade = false;
    
    // First try with normal cards
    for (const card of hand) {
        if (SPECIAL_JACKS[card]) continue; // Skip jacks for now
        
        // Find matching cells on board
        for (let row = 0; row < 10; row++) {
            for (let col = 0; col < 10; col++) {
                const cell = gameState.board[row][col];
                if (cell && cell.card === card && !cell.token) {
                    // Found a valid move
                    gameState.selectedCard = card;
                    makeOpponentMove(row, col);
                    moveMade = true;
                    return;
                }
            }
        }
    }
    
    // If no normal move, try one-eyed jacks
    if (!moveMade) {
        for (const card of hand) {
            if (SPECIAL_JACKS[card] === 'one-eyed') {
                // Look for opponent tokens not in a sequence
                const playerIndex = gameState.isHost ? 0 : 1;
                const playerColor = gameState.players[playerIndex].color;
                
                for (let row = 0; row < 10; row++) {
                    for (let col = 0; col < 10; col++) {
                        const cell = gameState.board[row][col];
                        if (cell && cell.token === playerColor && !isPartOfSequence(row, col)) {
                            // Found a valid move
                            gameState.selectedCard = card;
                            makeOpponentMove(row, col);
                            moveMade = true;
                            return;
                        }
                    }
                }
            }
        }
    }
    
    // If no normal or one-eyed jack move, try two-eyed jacks
    if (!moveMade) {
        for (const card of hand) {
            if (SPECIAL_JACKS[card] === 'two-eyed') {
                // Look for any empty cell
                for (let row = 0; row < 10; row++) {
                    for (let col = 0; col < 10; col++) {
                        const cell = gameState.board[row][col];
                        if (cell && !cell.token && !cell.isFree) {
                            // Found a valid move
                            gameState.selectedCard = card;
                            makeOpponentMove(row, col);
                            moveMade = true;
                            return;
                        }
                    }
                }
            }
        }
    }
    
    // If still no move, just play the first card on a random valid cell
    if (!moveMade && hand.length > 0) {
        const card = hand[0];
        gameState.selectedCard = card;
        
        // For simplicity, just discard the card and draw a new one
        const cardIndex = gameState.players[opponentIndex].hand.indexOf(card);
        if (cardIndex !== -1) {
            gameState.players[opponentIndex].hand.splice(cardIndex, 1);
        }
        
        // Draw a new card
        if (gameState.deck.length > 0) {
            gameState.players[opponentIndex].hand.push(gameState.deck.pop());
        }
        
        // Switch players
        gameState.currentPlayer = 1 - gameState.currentPlayer;
        renderGame();
    }
}

// Make opponent move
function makeOpponentMove(row, col) {
    const cardValue = gameState.selectedCard;
    const opponentIndex = gameState.isHost ? 1 : 0;
    
    // Check if special jack
    if (SPECIAL_JACKS[cardValue]) {
        if (SPECIAL_JACKS[cardValue] === 'one-eyed') {
            // Remove player token
            gameState.board[row][col].token = null;
        } else {
            // Place token
            gameState.board[row][col].token = gameState.players[opponentIndex].color;
        }
    } else {
        // Place token
        gameState.board[row][col].token = gameState.players[opponentIndex].color;
    }
    
    // Remove the played card from hand
    const cardIndex = gameState.players[opponentIndex].hand.indexOf(cardValue);
    if (cardIndex !== -1) {
        gameState.players[opponentIndex].hand.splice(cardIndex, 1);
    }
    
    // Draw a new card
    if (gameState.deck.length > 0) {
        gameState.players[opponentIndex].hand.push(gameState.deck.pop());
    }
    
    // Clear selected card
    gameState.selectedCard = null;
    
    // Check for sequences
    checkForSequences();
    
    // Check for win
    if (checkForWin()) {
        showNotification(`${gameState.players[opponentIndex].name} wins!`);
        setTimeout(() => {
            alert(`${gameState.players[opponentIndex].name} wins the game!`);
            window.location.reload();
        }, 1000);
        return;
    }
    
    // Switch players
    gameState.currentPlayer = 1 - gameState.currentPlayer;
    
    // Re-render
    renderGame();
    
    showNotification("Your turn!");
}

// WebSocket Connection (simulated for this example)
class WebSocketSimulation {
    constructor(gameId) {
        this.gameId = gameId;
        this.isConnected = false;
        this.onMessage = null;
        this.onClose = null;
        this.onOpen = null;
        
        // Simulate connection delay
        setTimeout(() => {
            this.isConnected = true;
            if (this.onOpen) this.onOpen();
        }, 1000);
    }
    
    send(message) {
        console.log('Message sent:', message);
        // In a real implementation, this would send to the server
    }
    
    close() {
        this.isConnected = false;
        if (this.onClose) this.onClose();
    }
    
    // Simulate receiving a message
    simulateReceive(message) {
        if (this.onMessage) {
            this.onMessage({ data: JSON.stringify(message) });
        }
    }
}

// Initialize websocket
let socket = null;

// Initialize game
document.addEventListener('DOMContentLoaded', initGame);

// In a real implementation, you would set up WebSocket communication
// between players to transmit moves and game state
